From: Cyrill Gorcunov <gorcunov@openvz.org>
Subject: [PATCH] fs, proc: Introduce the /proc/<pid>/children entry v4

There is no easy way to make a reverse parent->children chain
from arbitrary <pid> (while parent pid is provided in "PPid"
field of /proc/<pid>/status).

So instead of walking over all pids in the system to figure out which
children a task have -- we add explicit /proc/<pid>/children entry,
because kernel already has this kind of information but it is not
yet exported. This is a first level children, not the whole process
tree, neither the process threads are identified with this interface.

v2:
 - Kame suggested to use a separated /proc/<pid>/children entry
   instead of poking /proc/<pid>/status
 - Andew suggested to use rcu facility instead of locking
   tasklist_lock
 - Tejun pointed that non-seekable seq file might not be
   enough for tasks with large number of children

v3:
 - To be on a safe side use %lu format for pid_t printing

v4:
 - New line get printed when sequence ends not at seq->stop,
   a nit pointed by Tejun
 - Documentation update
 - tasklist_lock is back, Oleg pointed that ->children list
   is actually not rcu-safe

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Pavel Emelyanov <xemul@parallels.com>
Cc: Serge Hallyn <serge.hallyn@canonical.com>
Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Cc: Pavel Emelyanov <xemul@parallels.com>
---
 Documentation/filesystems/proc.txt |   20 ++++
 fs/proc/array.c                    |  163 +++++++++++++++++++++++++++++++++++++
 fs/proc/base.c                     |    1 
 fs/proc/internal.h                 |    6 +
 4 files changed, 190 insertions(+)

Index: linux-2.6.git/Documentation/filesystems/proc.txt
===================================================================
--- linux-2.6.git.orig/Documentation/filesystems/proc.txt
+++ linux-2.6.git/Documentation/filesystems/proc.txt
@@ -40,6 +40,7 @@ Table of Contents
   3.4	/proc/<pid>/coredump_filter - Core dump filtering settings
   3.5	/proc/<pid>/mountinfo - Information about mounts
   3.6	/proc/<pid>/comm  & /proc/<pid>/task/<tid>/comm
+  3.7	/proc/<pid>/children - Information about task children
 
 
 ------------------------------------------------------------------------------
@@ -1545,3 +1546,22 @@ a task to set its own or one of its thre
 is limited in size compared to the cmdline value, so writing anything longer
 then the kernel's TASK_COMM_LEN (currently 16 chars) will result in a truncated
 comm value.
+
+3.7	/proc/<pid>/children - Information about task children
+--------------------------------------------------------------
+This file provides a fast way to retrieve first level children pids
+of a task pointed by <pid>. The format is a stream of pids separated
+by space with a new line at the end. If a task has no children at
+all -- only a new line returned.
+
+Note the "first level" here -- if a child has own children they will
+not be printed there, one need to read /proc/<children-pid>/children
+to obtain descendants. The same applies to threads -- they are not
+counted here.
+
+Because this interface is intended to be fast and cheap it doesn't
+guarantee to provide the precise results, which means if a child is
+exiting it might or might not be counted. The same applies to freshly
+created children -- they might or might not be counted. If one needs
+precise pids -- the task and children should be either stopped or
+frozen.
Index: linux-2.6.git/fs/proc/array.c
===================================================================
--- linux-2.6.git.orig/fs/proc/array.c
+++ linux-2.6.git/fs/proc/array.c
@@ -547,3 +547,166 @@ int proc_pid_statm(struct seq_file *m, s
 
 	return 0;
 }
+
+static struct list_head *
+children_get_at(struct proc_pid_children_iter *iter, loff_t pos)
+{
+	struct task_struct *t = iter->group_leader;
+	struct task_struct *task;
+
+	rcu_read_lock();
+	do {
+		list_for_each_entry(task, &t->children, sibling) {
+			if (list_empty(&task->sibling))
+				break;
+			if (pos-- == 0) {
+				put_task_struct(iter->last_group);
+				iter->last_group = t;
+				get_task_struct(iter->last_group);
+				get_task_struct(task);
+				rcu_read_unlock();
+				return &task->sibling;
+			}
+		}
+	} while_each_thread(iter->group_leader, t);
+	rcu_read_unlock();
+
+	return NULL;
+}
+
+static int children_seq_show(struct seq_file *seq, void *v)
+{
+	struct task_struct *task = container_of(v, struct task_struct, sibling);
+	unsigned long pid;
+	int ret = -1;
+
+	rcu_read_lock();
+	if (pid_alive(task)) {
+		pid = (unsigned long)pid_vnr(task_pid(task));
+		ret = 0;
+	}
+	rcu_read_unlock();
+
+	if (!ret)
+		ret = seq_printf(seq, " %lu", pid);
+	return ret;
+}
+
+static void *children_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	return children_get_at(seq->private, *pos);
+}
+
+static void *children_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct proc_pid_children_iter *iter = seq->private;
+	struct task_struct *task = container_of(v, struct task_struct, sibling);
+	struct list_head *next = NULL;
+
+	if (!iter->last_group)
+		goto out;
+
+	rcu_read_lock();
+
+	if (list_empty(&task->sibling) ||
+	    list_is_last(v, &iter->last_group->children)) {
+		struct task_struct *t = iter->last_group;
+
+		while_each_thread(iter->group_leader, t) {
+			if (!list_empty(&t->children)) {
+				put_task_struct(task);
+				next = t->children.next;
+				task = container_of(next, struct task_struct, sibling);
+				get_task_struct(task);
+				put_task_struct(iter->last_group);
+				iter->last_group = t;
+				get_task_struct(iter->last_group);
+				goto out_unlock;
+			}
+		}
+
+		put_task_struct(task);
+		put_task_struct(iter->last_group);
+		iter->last_group = NULL;
+	} else {
+		next = ((struct list_head *)v)->next;
+		put_task_struct(task);
+		task = container_of(next, struct task_struct, sibling);
+		get_task_struct(task);
+	}
+out_unlock:
+	rcu_read_unlock();
+out:
+	++*pos;
+	if (!next)
+		seq_printf(seq, "\n");
+	return next;
+}
+
+static void children_seq_stop(struct seq_file *seq, void *v)
+{
+	struct proc_pid_children_iter *iter = seq->private;
+	if (iter->last_group)
+		put_task_struct(iter->last_group);
+	iter->last_group = NULL;
+}
+
+static const struct seq_operations children_seq_ops = {
+	.start	= children_seq_start,
+	.next	= children_seq_next,
+	.stop	= children_seq_stop,
+	.show	= children_seq_show,
+};
+
+static int children_seq_open(struct inode *inode, struct file *file)
+{
+	struct proc_pid_children_iter *iter = NULL;
+	struct task_struct *task = NULL;
+	int ret;
+
+	ret = -ENOMEM;
+	iter = kmalloc(sizeof(*iter), GFP_KERNEL);
+	if (!iter)
+		goto err;
+
+	ret = -ENOENT;
+	task = get_proc_task(inode);
+	if (!task)
+		goto err;
+
+	ret = seq_open(file, &children_seq_ops);
+	if (!ret) {
+		struct seq_file *m = file->private_data;
+		m->private = iter;
+		iter->group_leader = task;
+		iter->last_group = task;
+		get_task_struct(iter->last_group);
+	}
+
+err:
+	if (ret) {
+		if (task)
+			put_task_struct(task);
+		kfree(iter);
+	}
+
+	return ret;
+}
+
+int children_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *m = file->private_data;
+	struct proc_pid_children_iter *iter = m->private;
+
+	put_task_struct(iter->group_leader);
+	kfree(iter);
+	seq_release(inode, file);
+	return 0;
+}
+
+const struct file_operations proc_pid_children_operations = {
+	.open    = children_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = children_seq_release,
+};
Index: linux-2.6.git/fs/proc/base.c
===================================================================
--- linux-2.6.git.orig/fs/proc/base.c
+++ linux-2.6.git/fs/proc/base.c
@@ -3204,6 +3204,7 @@ static const struct pid_entry tgid_base_
 	INF("cmdline",    S_IRUGO, proc_pid_cmdline),
 	ONE("stat",       S_IRUGO, proc_tgid_stat),
 	ONE("statm",      S_IRUGO, proc_pid_statm),
+	REG("children",   S_IRUGO, proc_pid_children_operations),
 	REG("maps",       S_IRUGO, proc_maps_operations),
 #ifdef CONFIG_NUMA
 	REG("numa_maps",  S_IRUGO, proc_numa_maps_operations),
Index: linux-2.6.git/fs/proc/internal.h
===================================================================
--- linux-2.6.git.orig/fs/proc/internal.h
+++ linux-2.6.git/fs/proc/internal.h
@@ -53,6 +53,12 @@ extern int proc_pid_statm(struct seq_fil
 				struct pid *pid, struct task_struct *task);
 extern loff_t mem_lseek(struct file *file, loff_t offset, int orig);
 
+struct proc_pid_children_iter {
+	struct task_struct *group_leader;
+	struct task_struct *last_group;
+};
+
+extern const struct file_operations proc_pid_children_operations;
 extern const struct file_operations proc_maps_operations;
 extern const struct file_operations proc_numa_maps_operations;
 extern const struct file_operations proc_smaps_operations;
