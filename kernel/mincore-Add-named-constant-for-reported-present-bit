From: Cyrill Gorcunov <gorcunov@openvz.org>
Subject: [PATCH] mincore: Add named constant for reported present bit

From: Pavel Emelyanov <xemul@parallels.com>

Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
---
 include/linux/mman.h |    2 ++
 mm/huge_memory.c     |    2 +-
 mm/mincore.c         |   10 +++++-----
 3 files changed, 8 insertions(+), 6 deletions(-)

Index: linux-2.6.git/include/linux/mman.h
===================================================================
--- linux-2.6.git.orig/include/linux/mman.h
+++ linux-2.6.git/include/linux/mman.h
@@ -10,6 +10,8 @@
 #define OVERCOMMIT_ALWAYS		1
 #define OVERCOMMIT_NEVER		2
 
+#define MINCORE_RESIDENT	0x1
+
 #ifdef __KERNEL__
 #include <linux/mm.h>
 #include <linux/percpu_counter.h>
Index: linux-2.6.git/mm/huge_memory.c
===================================================================
--- linux-2.6.git.orig/mm/huge_memory.c
+++ linux-2.6.git/mm/huge_memory.c
@@ -1045,7 +1045,7 @@ int mincore_huge_pmd(struct vm_area_stru
 			 * All logical pages in the range are present
 			 * if backed by a huge page.
 			 */
-			memset(vec, 1, (end - addr) >> PAGE_SHIFT);
+			memset(vec, MINCORE_RESIDENT, (end - addr) >> PAGE_SHIFT);
 		}
 	} else
 		spin_unlock(&vma->vm_mm->page_table_lock);
Index: linux-2.6.git/mm/mincore.c
===================================================================
--- linux-2.6.git.orig/mm/mincore.c
+++ linux-2.6.git/mm/mincore.c
@@ -38,7 +38,7 @@ static void mincore_hugetlb_page_range(s
 				       addr & huge_page_mask(h));
 		present = ptep && !huge_pte_none(huge_ptep_get(ptep));
 		while (1) {
-			*vec = present;
+			*vec = (present ? MINCORE_RESIDENT : 0);
 			vec++;
 			addr += PAGE_SIZE;
 			if (addr == end)
@@ -83,7 +83,7 @@ static unsigned char mincore_page(struct
 		page_cache_release(page);
 	}
 
-	return present;
+	return present ? MINCORE_RESIDENT : 0;
 }
 
 static void mincore_unmapped_range(struct vm_area_struct *vma,
@@ -122,7 +122,7 @@ static void mincore_pte_range(struct vm_
 		if (pte_none(pte))
 			mincore_unmapped_range(vma, addr, next, vec);
 		else if (pte_present(pte))
-			*vec = 1;
+			*vec = MINCORE_RESIDENT;
 		else if (pte_file(pte)) {
 			pgoff = pte_to_pgoff(pte);
 			*vec = mincore_page(vma->vm_file->f_mapping, pgoff);
@@ -131,14 +131,14 @@ static void mincore_pte_range(struct vm_
 
 			if (is_migration_entry(entry)) {
 				/* migration entries are always uptodate */
-				*vec = 1;
+				*vec = MINCORE_RESIDENT;
 			} else {
 #ifdef CONFIG_SWAP
 				pgoff = entry.val;
 				*vec = mincore_page(&swapper_space, pgoff);
 #else
 				WARN_ON(1);
-				*vec = 1;
+				*vec = MINCORE_RESIDENT;
 #endif
 			}
 		}
