From 8b85d835bca59de5b5c318f6492be0c73d2da313 Mon Sep 17 00:00:00 2001
From: Cyrill Gorcunov <gorcunov@gmail.com>
Date: Tue, 8 Nov 2011 17:45:52 +0400
Subject: [PATCH 6/6] prctl: Add PR_CKPT_CTL helper

In a sake of checkpoint restore we need a number
of things to be tuned up at restore time, such as
vDSO address, task status, code start/end fields.

This is done via prctl interface.

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
---
 arch/x86/vdso/vma.c   |   33 +++++++++++++++++++++++++++++++++
 include/linux/prctl.h |   12 ++++++++++++
 kernel/sys.c          |   44 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 89 insertions(+), 0 deletions(-)

diff --git a/arch/x86/vdso/vma.c b/arch/x86/vdso/vma.c
index 153407c..e0b974f 100644
--- a/arch/x86/vdso/vma.c
+++ b/arch/x86/vdso/vma.c
@@ -137,6 +137,39 @@ up_fail:
 	return ret;
 }
 
+int arch_setup_additional_pages_at(void *addr)
+{
+	struct mm_struct *mm = current->mm;
+	int ret;
+
+	if (!vdso_enabled)
+		return 0;
+
+	down_write(&mm->mmap_sem);
+
+	/*
+	 * Unmap previous entry.
+	 */
+	if (mm->context.vdso) {
+		ret = do_munmap(mm, (unsigned long)mm->context.vdso, vdso_size);
+		if (ret)
+			goto err;
+	}
+
+	mm->context.vdso = addr;
+	ret = install_special_mapping(mm, (unsigned long)addr, vdso_size,
+				      VM_READ | VM_EXEC |
+				      VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC |
+				      VM_ALWAYSDUMP,
+				      vdso_pages);
+	if (ret)
+		mm->context.vdso = NULL;
+
+err:
+	up_write(&mm->mmap_sem);
+	return ret;
+}
+
 static __init int vdso_setup(char *s)
 {
 	vdso_enabled = simple_strtoul(s, NULL, 0);
diff --git a/include/linux/prctl.h b/include/linux/prctl.h
index a3baeb2..2b460ac 100644
--- a/include/linux/prctl.h
+++ b/include/linux/prctl.h
@@ -102,4 +102,16 @@
 
 #define PR_MCE_KILL_GET 34
 
+/* Checkpoint/restore specifics */
+#define PR_CKPT_CTL	35
+# define PR_CKPT_CTL_SETUP_VDSO_AT		1
+# define PR_CKPT_CTL_SET_TASK_FLAGS		2
+# define PR_CKPT_CTL_SET_MM_START_CODE		3
+# define PR_CKPT_CTL_SET_MM_END_CODE		4
+# define PR_CKPT_CTL_SET_MM_START_DATA		5
+# define PR_CKPT_CTL_SET_MM_END_DATA		6
+# define PR_CKPT_CTL_SET_MM_START_STACK		7
+# define PR_CKPT_CTL_SET_MM_START_BRK		8
+# define PR_CKPT_CTL_SET_MM_BRK			9
+
 #endif /* _LINUX_PRCTL_H */
diff --git a/kernel/sys.c b/kernel/sys.c
index 481611f..2bdb30c 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -123,6 +123,12 @@ EXPORT_SYMBOL(cad_pid);
 
 void (*pm_power_off_prepare)(void);
 
+#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES
+extern int arch_setup_additional_pages_at(void *addr);
+#else
+static int arch_setup_additional_pages_at(void *addr) { return 0; }
+#endif
+
 /*
  * Returns true if current's euid is same as p's uid or euid,
  * or has CAP_SYS_NICE to p's user_ns.
@@ -1841,6 +1847,44 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 			else
 				error = PR_MCE_KILL_DEFAULT;
 			break;
+		case PR_CKPT_CTL:
+			if (arg4 | arg5)
+				return -EINVAL;
+			switch (arg2) {
+#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES
+			case PR_CKPT_CTL_SETUP_VDSO_AT:
+				error = arch_setup_additional_pages_at((void *)arg3);
+				break;
+#endif
+			case PR_CKPT_CTL_SET_TASK_FLAGS:
+				current->flags = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_START_CODE:
+				current->mm->start_code = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_END_CODE:
+				current->mm->end_code = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_START_DATA:
+				current->mm->start_data = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_END_DATA:
+				current->mm->end_data = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_START_STACK:
+				current->mm->start_stack = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_START_BRK:
+				current->mm->start_brk = arg3;
+				break;
+			case PR_CKPT_CTL_SET_MM_BRK:
+				current->mm->brk = arg3;
+				break;
+			default:
+				error = -EINVAL;
+				break;
+			}
+			break;
 		default:
 			error = -EINVAL;
 			break;
-- 
1.7.6.4

